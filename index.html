<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Eric Denovellis">
  <title>Better Science Code</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="revealjs/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="revealjs/css/theme/black.css" id="theme">
  <link rel="stylesheet" href="css/custom.css"/>
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'revealjs/css/print/pdf.css' : 'revealjs/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="revealjs/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">Better Science Code</h1>
  <p class="author">Eric Denovellis</p>
</section>

<section class="slide level6">

<p>Presentation: <a href="http://edeno.github.io/Better-Science-Code">https://edeno.github.io/Better-Science-Code</a></p>
</section>
<section class="slide level6">

<p>Repository: <a href="https://github.com/edeno/Better-Science-Code" class="uri">https://github.com/edeno/Better-Science-Code</a></p>
</section>
<section class="slide level6">

<p>Why should you care about producing good code</p>
</section>
<section class="slide level6">

<ol type="1">
<li>Doing good science!</li>
</ol>
</section>
<section class="slide level6">

<p>We want code that works (<strong>it does what you say it does</strong>) and is reproducible (<strong>you can get to the same result every time using the same data and code</strong>):</p>
</section>
<section class="slide level6">

<p>Don’t want to have to retract papers because the code had bugs</p>
</section>
<section class="slide level6">

<p>Following good coding practices reduces the chance of making mistakes</p>
</section>
<section class="slide level6">

<p>It’s too easy to make mistakes</p>
</section>
<section class="slide level6">

<blockquote>
<p>As the complexity of a software program increases, the likelihood of undiscovered bugs quickly reaches certainty” – <cite>Poldrack et al. 2017</cite></p>
</blockquote>
</section>
<section class="slide level6">

<p><strong>We are writing complex code</strong></p>
<aside class="notes">
Good code should reduce your anxiety about making mistakes
</aside>
</section>
<section class="slide level6">

<ol start="2" type="1">
<li>Want to remember what the code does months later</li>
</ol>
</section>
<section class="slide level6">

<blockquote>
<p>The single biggest reason you should write nice code is so that your future self can understand it. – <cite>Greg Wilson</cite></p>
</blockquote>
<blockquote>
<p>“All code has at least one collaborator and that is future you.” – <cite>Hadley Wickham</cite></p>
</blockquote>
</section>
<section class="slide level6">

<ol start="3" type="1">
<li>Want to be able to share it with other people</li>
</ol>
</section>
<section class="slide level6">

<p>Particularly important with statistical methods development</p>
<aside class="notes">
<ul>
<li>what’s the point of coming up with a method if other people can’t easily use it or verify that it works</li>
<li>increase the impact of your paper if other people can use your method</li>
<li>if neuroscience is increasingly relying on larger teams of people working together, those teams need to be able to share code</li>
</ul>
Example: Michael Shadlen vs. Jonathan Pillow debate about the dynamics neurons during perceptual decision making tasks (Ramping diffusion to bound model vs. stepping model) * Pillow lab released several papers arguing for stepping model with code available on Github * Shadlen lab recently countered with a paper arguing against the stepping model using the Pillow lab code
</aside>
</section>
<section class="slide level6">

<ol start="4" type="1">
<li>Avoid introducing new errors</li>
</ol>
</section>
<section class="slide level6">

<ol start="5" type="1">
<li>Can serve as a resume for future employers</li>
</ol>
</section>
<section class="slide level6">

<p>How to write good code?</p>
</section>
<section class="slide level6">

<p>Exercise in how to manage complexity:</p>
<ul>
<li>break problems down into smaller components</li>
<li>eliminate unnecessary dependencies</li>
<li>keep track of what you did (be organized)</li>
</ul>
</section>
<section class="slide level6">

<p>Goal: Want to form good habits</p>
</section>
<section class="slide level6">

<p>Don’t be overwhelmed and not do any of these things</p>
</section>
<section class="slide level6">

<p>Don’t beat yourself up if you don’t do all these things all the time</p>
<aside class="notes">
<ul>
<li>just try to remember them and incorporate them gradually into your process</li>
<li>it will slow your coding process initially, but you will gain precision, readability</li>
<li>some of these will require more inertia (such as version control)</li>
</ul>
</aside>
</section>
<section class="slide level6">

<ol type="1">
<li>Decompose programs into small, well-defined functions</li>
</ol>
<aside class="notes">
Biggest mistake I see in scientific code
</aside>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> bad_function():
    X <span class="op">=</span> np.load(<span class="st">&#39;/tmp/123.npy&#39;</span>, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    y, x1, x2 <span class="op">=</span> X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], X[:, <span class="dv">2</span>]
    z1 <span class="op">=</span> (x1 <span class="op">-</span> x1.mean()) <span class="op">/</span> x1.std()
    Q1, R1 <span class="op">=</span> np.linalg.qr(z1, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    b1 <span class="op">=</span> np.linalg.solve(R1, np.dot(Q1.T, y1))
    z2 <span class="op">=</span> (x2 <span class="op">-</span> x2.mean()) <span class="op">/</span> x2.std()
    Q2, R2 <span class="op">=</span> np.linalg.qr(z1, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    b2 <span class="op">=</span> np.linalg.solve(R2, np.dot(Q2.T, y2))
    b <span class="op">=</span> b1 <span class="op">-</span> b2
    np.save(<span class="st">&#39;ans.npy&#39;</span>, b)</code></pre></div>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> better_function():
    y, x1, x2 <span class="op">=</span> load_data(<span class="st">&#39;/tmp/123.npy&#39;</span>)
    b1 <span class="op">=</span> linear_regression(zscore(x1), y)
    b2 <span class="op">=</span> linear_regression(zscore(x2), y)
    b <span class="op">=</span> b1 <span class="op">-</span> b2
    np.save(<span class="st">&#39;ans.npy&#39;</span>, b)

<span class="kw">def</span> load_data(data_name):
    X <span class="op">=</span> np.load(data_name, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    <span class="cf">return</span> X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], X[:, <span class="dv">2</span>]

<span class="kw">def</span> zscore(x):
    <span class="cf">return</span> (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std()

<span class="kw">def</span> linear_regression(design_matrix, response):
    Q, R <span class="op">=</span> np.linalg.qr(design_matrix, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    <span class="cf">return</span> np.linalg.solve(R, np.dot(Q.T, response))</code></pre></div>
</section>
<section class="slide level6">

<p>Try to keep functions to less than 60 lines (small)</p>
</section>
<section class="slide level6">

<p>Try to keep what the function does as simple as possible (well-defined)</p>
<aside class="notes">
<p>atomic = a function should do one “thing”</p>
<p>Think about if you came back to the function later, how long would it take you to understand what it does? * should be able to explain what it does in one sentence</p>
pure = as few implicit contexts and side-effects as possible.
</aside>
</section>
<section class="slide level6">

<p>Be ruthless about eliminating duplication of code</p>
<aside class="notes">
<ul>
<li>turn duplicated code into functions</li>
<li>that way fixing a bug in your function, fixes it for every time the function is used instead of every separate instance</li>
</ul>
</aside>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> bad_function():
    X <span class="op">=</span> np.load(<span class="st">&#39;/tmp/123.npy&#39;</span>, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    y, x1, x2 <span class="op">=</span> X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], X[:, <span class="dv">2</span>]
    z1 <span class="op">=</span> (x1 <span class="op">-</span> x1.mean()) <span class="op">/</span> x1.std()
    Q1, R1 <span class="op">=</span> np.linalg.qr(z1, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    b1 <span class="op">=</span> np.linalg.solve(R1, np.dot(Q1.T, y1))
    z2 <span class="op">=</span> (x2 <span class="op">-</span> x2.mean()) <span class="op">/</span> x2.std()
    Q2, R2 <span class="op">=</span> np.linalg.qr(z1, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    b2 <span class="op">=</span> np.linalg.solve(R2, np.dot(Q2.T, y2))
    b <span class="op">=</span> b1 <span class="op">-</span> b2
    np.save(<span class="st">&#39;ans.npy&#39;</span>, b)</code></pre></div>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> better_function():
    y, x1, x2 <span class="op">=</span> load_data(<span class="st">&#39;/tmp/123.npy&#39;</span>)
    b1 <span class="op">=</span> linear_regression(zscore(x1), y)
    b2 <span class="op">=</span> linear_regression(zscore(x2), y)
    b <span class="op">=</span> b1 <span class="op">-</span> b2
    np.save(<span class="st">&#39;ans.npy&#39;</span>, b)

<span class="kw">def</span> load_data(data_name):
    X <span class="op">=</span> np.load(data_name, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    <span class="cf">return</span> X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], X[:, <span class="dv">2</span>]

<span class="kw">def</span> zscore(x):
    <span class="cf">return</span> (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std()

<span class="kw">def</span> linear_regression(design_matrix, response):
    Q, R <span class="op">=</span> np.linalg.qr(design_matrix, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    <span class="cf">return</span> np.linalg.solve(R, np.dot(Q.T, response))</code></pre></div>
</section>
<section class="slide level6">

<p>Small, well-defined functions are more <strong>maintainable</strong></p>
<aside class="notes">
<ul>
<li>breaks hard problems down into smaller problems</li>
<li>limits the scope of your code</li>
<li>makes it easier to debug or change (with unit testing)</li>
<li>separation of concerns</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>Small, well-defined functions are more <strong>composable</strong></p>
<aside class="notes">
<ul>
<li>can reuse function in other programs</li>
<li>can pass functions to other functions (function composition)</li>
<li>makes you more efficient because you don’t have to rewrite code</li>
<li>makes you more precise because you can focus on fixing bugs for one function, not many similar functions</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>Small, well-defined functions are more <strong>readable</strong></p>
<p>* if you give them good names</p>
</section>
<section class="slide level6">

<blockquote>
<p>“Programs are meant to be read by humans and only incidentally for computers to execute” – <cite>Donald Knuth</cite></p>
</blockquote>
<aside class="notes">
encapsulate ideas in functions
</aside>
</section>
<section class="slide level6">

<ol start="2" type="1">
<li>Use good variable/function names to clarify what things do</li>
</ol>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> bad_function():
    X <span class="op">=</span> np.load(<span class="st">&#39;/tmp/123.npy&#39;</span>, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    y, x1, x2 <span class="op">=</span> X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], X[:, <span class="dv">2</span>]
    z1 <span class="op">=</span> (x1 <span class="op">-</span> x1.mean()) <span class="op">/</span> x1.std()
    Q1, R1 <span class="op">=</span> np.linalg.qr(z1, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    b1 <span class="op">=</span> np.linalg.solve(R1, np.dot(Q1.T, y1))
    z2 <span class="op">=</span> (x2 <span class="op">-</span> x2.mean()) <span class="op">/</span> x2.std()
    Q2, R2 <span class="op">=</span> np.linalg.qr(z1, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    b2 <span class="op">=</span> np.linalg.solve(R2, np.dot(Q2.T, y2))
    b <span class="op">=</span> b1 <span class="op">-</span> b2
    np.save(<span class="st">&#39;ans.npy&#39;</span>, b)</code></pre></div>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> better_function():
    y, x1, x2 <span class="op">=</span> load_data(<span class="st">&#39;/tmp/123.npy&#39;</span>)
    b1 <span class="op">=</span> linear_regression(zscore(x1), y)
    b2 <span class="op">=</span> linear_regression(zscore(x2), y)
    b <span class="op">=</span> b1 <span class="op">-</span> b2
    np.save(<span class="st">&#39;ans.npy&#39;</span>, b)

<span class="kw">def</span> load_data(data_name):
    X <span class="op">=</span> np.load(data_name, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    <span class="cf">return</span> X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], X[:, <span class="dv">2</span>]

<span class="kw">def</span> zscore(x):
    <span class="cf">return</span> (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std()

<span class="kw">def</span> linear_regression(design_matrix, response):
    Q, R <span class="op">=</span> np.linalg.qr(design_matrix, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    <span class="cf">return</span> np.linalg.solve(R, np.dot(Q.T, response))</code></pre></div>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> better_function():
    response, design_matrix1, design_matrix2 <span class="op">=</span> load_data(
        <span class="st">&#39;/tmp/123.npy&#39;</span>)
    coefficient1 <span class="op">=</span> linear_regression(
        zscore(design_matrix1), response)
    coefficient2 <span class="op">=</span> linear_regression(
        zscore(design_matrix2), response)
    coefficient_difference <span class="op">=</span> coefficient1 <span class="op">-</span> coefficient2
    np.save(<span class="st">&#39;ans.npy&#39;</span>, b)

<span class="kw">def</span> load_data(data_name):
    X <span class="op">=</span> np.load(data_name, mmap_mode<span class="op">=</span><span class="st">&#39;r&#39;</span>)
    <span class="cf">return</span> X[:, <span class="dv">0</span>], X[:, <span class="dv">1</span>], X[:, <span class="dv">2</span>]

<span class="kw">def</span> zscore(x):
    <span class="cf">return</span> (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std()

<span class="kw">def</span> linear_regression(design_matrix, response):
    Q, R <span class="op">=</span> np.linalg.qr(design_matrix, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    <span class="cf">return</span> np.linalg.solve(R, np.dot(Q.T, response))</code></pre></div>
</section>
<section class="slide level6">

<p>You don’t need comments if the variable or function already tells you what it does (self-documenting)</p>
<aside class="notes">
<ul>
<li>People have been taught to use comments in their code</li>
<li>Modern practice is to use commenting sparingly within the body of the code</li>
<li>Use comments to document what the functions does at the beginning of the function (will come back to this)</li>
<li>doesn’t mean never use comments, but don’t use them to restate what the code already says.</li>
<li>Makes it easier to read</li>
<li>When it is difficult to come up with a meaningful name for the function (It is probably doing too much)</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>Use the naming conventions of your language of choice (<code>snake_case</code> or <code>camelCase</code>) and be consistent</p>
</section>
<section class="slide level6">

<p>Avoid using abbreviations that are not commonly used</p>
<p>(<code>jmi</code> vs. <code>joint_mark_intensity</code>)</p>
</section>
<section class="slide level6">

<p>Prefer whole words</p>
<p>(<code>elec_poten</code> vs. <code>electric_potential</code>)</p>
</section>
<section class="slide level6">

<ol start="3" type="1">
<li>Document your functions</li>
</ol>
</section>
<section class="slide level6">

<p>Easy thing: brief sentence describing the function without using the name of the function</p>
<p>*<strong>this is the most important</strong></p>
<aside class="notes">
<ul>
<li>second line of defense in remembering what a function does</li>
<li>The more important the function, the more it should be documented</li>
<li>if using python, use the numpy format</li>
<li>if using matlab, use the matlab format</li>
<li>documentation often longer than the code itself</li>
</ul>
</aside>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> zscore(x):
    <span class="co">&#39;&#39;&#39;Number of standard deviations from the mean&#39;&#39;&#39;</span>
    <span class="cf">return</span> (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std()

<span class="kw">def</span> linear_regression(design_matrix, response):
    <span class="co">&#39;&#39;&#39;Calculate a linear least-squares regression for two sets of measurements&#39;&#39;&#39;</span>
    Q, R <span class="op">=</span> np.linalg.qr(design_matrix, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    <span class="cf">return</span> np.linalg.solve(R, np.dot(Q.T, response))</code></pre></div>
</section>
<section class="slide level6">

<p>More complicated thing:</p>
<ul>
<li>additional detail about what the function does or method it implements</li>
<li>description of the parameters (type, shape)</li>
<li>description of the outputs (type, shape)</li>
<li>examples if you can</li>
</ul>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> linear_regression(design_matrix, response):
    <span class="co">&#39;&#39;&#39;Calculate a linear least-squares regression for two sets of measurements</span>

<span class="co">    Parameters</span>
<span class="co">    ----------</span>
<span class="co">    design_matrix, response : array_like</span>
<span class="co">        Two sets of measurements. Both arrays should have the same length.</span>

<span class="co">    Returns</span>
<span class="co">    -------</span>
<span class="co">    coefficients : array_like</span>

<span class="co">    &#39;&#39;&#39;</span>
    Q, R <span class="op">=</span> np.linalg.qr(design_matrix, mode<span class="op">=</span><span class="st">&#39;reduced&#39;</span>)
    <span class="cf">return</span> np.linalg.solve(R, np.dot(Q.T, response))</code></pre></div>
</section>
<section class="slide level6">

<ol start="4" type="1">
<li>Test your code</li>
</ol>
</section>
<section class="slide level6">

<p>Make sure your code works like you think it does</p>
</section>
<section class="slide level6">

<p>Think about how your code can fail</p>
</section>
<section class="slide level6">

<p><strong>Small, well-defined, well-named functions are easy to test!</strong></p>
</section>
<section class="slide level6">

<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> numpy <span class="im">as</span> np

<span class="kw">def</span> zscore(x):
    <span class="co">&#39;&#39;&#39;Number of standard deviations from the mean&#39;&#39;&#39;</span>
    <span class="cf">return</span> (x <span class="op">-</span> x.mean()) <span class="op">/</span> x.std()

<span class="kw">def</span> test_zscore():
    test_values <span class="op">=</span> np.asarray([<span class="dv">1</span>, <span class="dv">3</span>])
    expected_values <span class="op">=</span> np.asarray([<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>])

    <span class="cf">assert</span> np.allclose(zscore(test_values), expected_values)</code></pre></div>
</section>
<section class="slide level6">

<p>Unit tests</p>
</section>
<section class="slide level6">

<p>Unit tests test a small component of your code (usually a small function) and makes sure it works like you think it works</p>
<aside class="notes">
<ul>
<li>Isolate small components of program and make sure they are correct</li>
<li>doesn’t ensure that combinations of these functions work (integration testing)</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>Unit tests prevent regression of your code</p>
</section>
<section class="slide level6">

<p>If you change your code, you want to know what still works and what has broken</p>
</section>
<section class="slide level6">

<p><strong>Functions should be simple to test</strong></p>
<aside class="notes">
<ul>
<li>if the number of test cases is uncomfortably large, start looking for smaller units to test.</li>
<li>your function is probably too complex</li>
<li>After reproducing the bug, and before fixing it, you should write a test case that fails, thus illustrating the bug.</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>If you find a bug, write a test.</p>
<aside class="notes">
After reproducing the bug, and before fixing it, you should write a test case that fails, thus illustrating the bug.
</aside>
</section>
<section class="slide level6">

<p>Use unit tests to define the requirements of your code</p>
<aside class="notes">
<ul>
<li>ensure that your function is well-defined</li>
<li>some people even write unit tests before writing a function (test-driven development)</li>
<li>also a form of documentation: examples for how you think your code should work</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>You can use programs called “test runners” to run a group of unit tests automatically.</p>
</section>
<section class="slide level6">

<p>Matlab, Python have built-in unit test programs</p>
<ul>
<li><a href="https://www.mathworks.com/help/matlab/matlab-unit-test-framework.html">Matlab unit test framework</a></li>
<li><a href="https://docs.python.org/3.4/library/unittest.html">Python unit test</a></li>
<li><a href="http://doc.pytest.org/en/latest/">Pytest</a></li>
<li><a href="https://github.com/hadley/testthat">R: testthat</a></li>
</ul>
</section>
<section class="slide level6">

<p>There are also libraries available that will work with your version control system to run these tests every time you commit a new piece of code (<code>continuous integration</code>)</p>
<aside class="notes">
<ul>
<li>This all seems complicated but in the process of developing code, you should be writing tests to make sure it works. This process just formalizes the writing of tests and allows you to run them at a later time, ensuring peace of mind.</li>
<li>yields more predictable code</li>
<li>in order to write a test, you have to know what the function does</li>
<li>people can look at your tests to understand your code (form of documentation)</li>
</ul>
</aside>
</section>
<section class="slide level6">

<ol start="5" type="1">
<li>Use version control</li>
</ol>
</section>
<section class="slide level6">

<p>Sophisticated way to track change in your code over time</p>
<aside class="notes">
<ul>
<li>dropbox is a form of this (but not very sophisticated)</li>
<li>microsoft word is also a form of this (but not very sophisticated)</li>
<li>snapshots of all the files in a folder (repository)</li>
<li>git is the most popular (some time is needed to learn this, but social/collaborative/popularity make it worth it)</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>Version control stores the whole history of your project</p>
</section>
<section class="slide level6">

<p>Helps you back up your work</p>
</section>
<section class="slide level6">

<p>Go back to previous versions of your code</p>
</section>
<section class="slide level6">

<p>Reduce code clutter and confusion</p>
<aside class="notes">
<ul>
<li>no more code_v1.m, code_v2.m</li>
<li>which version of code was I using???</li>
<li>which version of code worked???</li>
<li>how is this different from other code I wrote???</li>
</ul>
</aside>
</section>
<section class="slide level6">

<p>Experiment with different versions of code (branches)</p>
</section>
<section class="slide level6">

<p>Makes it easier to work with others</p>
<aside class="notes">
<ul>
<li>standardized way of not unintentionally overwriting each others code</li>
<li>easy to share code (GitHub, Bitbucket, etc)</li>
<li>makes it easier to document issues with code or data</li>
<li>Use example from this presentation
<aside></li>
</ul>
</section>
<section class="slide level6">

<p>Commit early and often</p>
<aside class="notes">
<ul>
<li>when you get a piece of code working, commit it (take a snapshot)</li>
<li>Leave a short informative commit message (document what the commit is)</li>
<li>don’t comment out code, just remove it, you can get back</li>
<li>I personally use GitHub Desktop
<ul>
<li>easy to use user interface
<aside></li>
</ul></li>
</ul>
</section>
<section class="slide level6">

<ol start="6" type="1">
<li>Refactor your code</li>
</ol>
</section>
<section class="slide level6">

<blockquote>
<p>“Whenever I have to think to understand what the code is doing, I ask myself if I can refactor the code to make that understanding more immediately apparent.” – <cite>Martin Fowler, Refactoring: Improving the Design of Existing Code</cite></p>
</blockquote>
</section>
<section class="slide level6">

<p>Always leave the code in a better state than when you first found it.</p>
<aside class="notes">
<p>Your code isn’t going to be perfect the first time</p>
<p>Just like in writing, your code will get better as you revise it.</p>
<p>You wouldn’t expect a first draft to be perfect.</p>
<p>each time you look at your code: * do my variable/function names make sense? * do I know what this function is doing? * can I turn things into functions? * can I generalize this function?</p>
<p>There is some tradeoff between tinkering with your code and getting things done</p>
Also don’t throw everything out and re-write from scratch unless you can absolutely help it * “When you throw away code and start from scratch, you are throwing away all that knowledge. All those collected bug fixes.” If tempted by this tutorial to do this to your existing codebase, don’t
<aside>
</section>
<section class="slide level6">

<ol start="7" type="1">
<li>Always search for well-maintained software libraries that do what you need.</li>
</ol>
</section>
<section class="slide level6">

<p>Don’t rewrite functions that are already implemented as part of the core language.</p>
</section>
<section class="slide level6">

<p>Use other software libraries if they are well-maintained</p>
<aside class="notes">
<p>Why: * because more users mean less bugs * better tested</p>
Little tricky: still need to take time to vet the code to make sure it does what you think it does
<aside>
</section>
<section class="slide level6">

<p>Summary:</p>
<ol type="1">
<li>Write small well-defined, well-named functions</li>
<li>Use good function and variable names</li>
<li>Document your functions</li>
<li>Test your code</li>
<li>Refactor your code</li>
<li>Use version control</li>
<li>Always search for well-maintained software libraries that do what you need.</li>
</ol>
</section>
<section class="slide level6">

<p>Conclusion: Writing good code takes work</p>
</section>
<section class="slide level6">

<p>We have a scientific obligation to ensure the correctness of our programs.</p>
<aside class="notes">
I think it is a mistake to think that only “programmers” working for companies need to bother with writing good code. You are a programmer dealing with complex programs.
</aside>
</section>
<section class="slide level6">

<p>Bonus: Data Management</p>
</section>
<section class="slide level6">

<p>Put different projects in different folders/repositories</p>
</section>
<section class="slide level6">

<p>Use relative paths</p>
</section>
<section class="slide level6">

<p>Separate the data from the code</p>
</section>
<section class="slide level6">

<p>Processed Data should be separated from Raw Data to avoid accidentally changing the data</p>
</section>
<section class="slide level6">

<p>Tidy Data:</p>
<ul>
<li>Each variable forms a column.</li>
<li>Each observation forms a row.</li>
<li>Each type of observational unit forms a table</li>
<li>flat is better than nested</li>
</ul>
</section>
<section class="slide level6">

<p>If original data is not in a good form, convert it to a good form (but don’t overwrite the original data)</p>
</section>
<section class="slide level6">

<p>Don’t hand-edit data files.</p>
</section>
<section class="slide level6">

<p>All aspects of data cleaning should be in scripts</p>
</section>
    </div>
  </div>

  <script src="revealjs/lib/js/head.min.js"></script>
  <script src="revealjs/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Display controls in the bottom right corner
        controls: false,
        // Display the page number of the current slide
        slideNumber: "c/t",
        // Push each slide change to the browser history
        history: true,
        // Transition style
        transition: 'none', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'revealjs/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'revealjs/plugin/zoom-js/zoom.js', async: true },
              { src: 'revealjs/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
